# Used as a 'bank'
from collections import defaultdict
# Decimal is used to store monetary values precisely
from decimal import Decimal
import logging
const = import_da('const')


class Server(process):

    def setup(servers, bank_name, conf, logfile):
        # TODO: Remove servers and setup_chain(servers)
        # TODO: add predecessor, successor to setup args
        self.predecessor = None
        self.successor = None
        self.is_head = True
        self.is_tail = True
        #self.processed_updates
        self.updates = dict()
        self.bank = defaultdict(int)
        self.lifetime = conf['lifetime']
        self.recv_limit = conf['receive']
        self.send_limit = conf['send']
        setup_chain(servers)

    def setup_chain(servers):
        slen = len(servers)
        i = servers.index(self.id)
        if i < slen - 1:
            set_successor(servers[i + 1])
        if i > 0:
            set_predecessor(servers[i - 1])

    def set_predecessor(new_pred):
        predecessor = new_pred
        is_head = False

    def set_successor(new_suc):
        successor = new_suc
        is_tail = False

    def setup_logfile():
        rootlog = logging.getLogger('')
        filelvl = logging.INFO
        fh = logging.FileHandler(logfile)
        formatter = logging.Formatter('[%(asctime)s]%(name)s: %(message)s')
        fh.setFormatter(formatter)
        fh.setLevel(filelvl)
        rootlog._filelvl = filelvl
        rootlog.addHandler(fh)

    def print_init_settings():
        output('*** Initial settings ***')
        if is_head:
            output('Operating as head server')
        if is_tail:
            output('Operating as tail server')
        if not is_tail and not is_head:
            output('Operating as internal server')
        if predecessor:
            output('Predecessor is %s' % predecessor)
        if successor:
            output('Successor is %s' % successor)
        if lifetime >= 0:
            output('Server will shutdown after %s seconds' % lifetime)
        else:
            output('Server has no time constraint')
        if recv_limit >= 0:
            output('Server will shutdown after receiving %s messages' % recv_limit)
        else:
            output('Server has no message receive constraint')
        if send_limit >= 0:
            output('Server will shutdown after sending %s messages' % send_limit)
        else:
            output('Server has no message send constraint')
        output('*** Initial settings ***')

    def main():
        setup_logfile()
        print_init_settings()
        if lifetime >= 0:
            # wait t seconds, until we send s messages, or receive r messages
            if await(len(listof(mesg, received(mesg))) == recv_limit):
                pass
            elif len(listof(mesg, sent(mesg))) == send_limit:
                pass
            elif timeout(lifetime):
                pass
        else:
            # wait forever, until we send s messages, or receive r messages
            if await(len(listof(mesg, received(mesg))) == recv_limit):
                pass
            elif len(listof(mesg, sent(mesg))) == send_limit:
                pass
        output("Terminating..")

    def receive(msg=('balance', uid), from_=client):
        # Only tail replies to clients
        if not is_tail:
            return
        # get account num from the uid
        acc = uid[2]
        outcome = const.PROCESSED
        send(('reply', (uid, outcome, bank[acc])), to=client)

# TODO: COMBINE these 2 methods!

    def receive(msg=('withdrawal', (uid, amount)), from_=p):
        # If we are not the head server ignore client updates
        if not is_head and (p != predecessor):
            return
        this_msg = ('withdrawal', (uid, amount))

        # check if this request is a duplicate or inconsisternt
        reply = dup_or_incon(uid, this_msg)
        if not reply:
            # get account num from the update id
            acc = uid[2]
            # withdrawal his $$$
            if bank[acc] >= Decimal(amount):
                bank[acc] -= Decimal(amount)
                outcome = const.PROCESSED
            else:
                outcome = const.INSUFFICIENT_FUNDS
            reply = ('reply', (uid, outcome, bank[acc]))
            # Save this update to our update history
            add_to_updates(uid, this_msg, reply)

        # forward the update
        fwd_update(this_msg, reply, uid[0])

    def receive(msg=('deposit', (uid, amount)), from_=p):
        # If we are not the head server ignore client updates
        if not is_head and (p != predecessor):
            return
        this_msg = ('deposit', (uid, amount))

        # check if this request is a duplicate or inconsisternt
        reply = dup_or_incon(uid, this_msg)
        if not reply:
            # get account num from the update id
            acc = uid[2]
            # Deposit his $$$
            bank[acc] += Decimal(amount)
            reply = ('reply', (uid, const.PROCESSED, bank[acc]))
            # Save this update to our update history
            add_to_updates(uid, this_msg, reply)

        # forward the update
        fwd_update(this_msg, reply, uid[0])

    def fwd_update(orig_msg, reply, client):
        if is_tail:
            # Reply to the client
            output('Sending client reply %s' % str(reply))
            send(reply, to=client)
        else:
            # Forward the update to successor
            output('Forwarding update %s' % str(orig_msg))
            send(orig_msg, to=successor)

    def add_to_updates(uid, request, reply):
        assert uid not in updates, 'Error: request id %s already exisits in updates' % str(uid)
        updates[uid] = (request, reply)

    def get_prev_mesg(uid):
        return updates[uid][0]

    def get_prev_reply(uid):
        return updates[uid][1]

    def dup_or_incon(uid, req_msg):
        """
        Check to see id this uid has been processed already. If the message
        is the same then return the original reply otherwise a reply is
        generated with outcome as INCONSISTENT and the current balance
        """
        if uid in updates:
            # We have processed this uid already
            if req_msg == get_prev_mesg(uid):
                # DUPLICATE RESEND ORIGIN
                output('\nDUPLICATE RESEND ORIGIN\n')
                return get_prev_reply(uid)
            else:
                # Inconsistent
                output('\nINCONSISTENT WITH updates\n')
                return ('reply', (uid, const.INCONSISTENT, bank[uid[2]]))
        return None
