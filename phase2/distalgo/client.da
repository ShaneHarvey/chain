import sys
import time
# Used as a 'bank'
from collections import defaultdict
# Decimal is used to store monetary values precisely
from decimal import Decimal

# DistAlgo code for chain replication client, based on the pseudocode in
# [vanRenesse2010Replication, Figure 2.5]
class Client(process):

    def setup(servers, head, tail):
        # timeout and retransmit after 3 seconds
        # This is the only timeout in the design
        self.T = 3
        self.responses = set()
        self.seq = 0

    def receive(msg=('response', r), from_=tail):
        responses.add((tail,r))

    def send_update(update, amount, bank, account):
        uid = gen_uid(bank, account)
        while True:
            if not head:
                return 'unavailable'
            send((update, (uid, amount)), to=head)
            if await(some((_, (ruid, r)) in responses, has=(ruid == uid))):
                return r
            elif timeout(T):
                pass

    def gen_uid(bank, account):
        seq += 1
        return (self.id, bank, account, seq)

    def main():
        for x in range(10):
            reply = send_update('deposit', '40.00', 'Chase', '001')
            output('reply %s' % reply)
            time.sleep(1)
        time.sleep(3)
        send(('Done',), to=servers)
        output("Terminating..")


class Server(process):

    def setup(servers):
        # TODO: Replace with implict place in servers list?
        self.predecessor  = None
        self.sucessor = None
        self.is_head = True
        self.is_tail = True
        self.history = set()
        self.bank_name = 'Chase'
        # Keys not in
        self.bank = defaultdict(int)
        setup_chain(servers)

    def setup_chain(servers):
        slen = len(servers)
        i = servers.index(self.id)
        if i < slen - 1:
            set_sucessor(servers[i + 1])
        if i > 0:
            set_predecessor(servers[i - 1])
        if not predecessor:
            output("I am head: %s" % self.id)

    def set_predecessor(new_pred):
        self.predecessor = new_pred
        is_head = False

    def set_sucessor(new_suc):
        self.sucessor = new_suc
        self.is_tail = False

    def main():
        # wait for 10 seconds
        if await(0):
            output("Terminating..")
        elif timeout(10):
            output("Terminating..")

    def receive(msg=('balance', (uid, q)), from_=client):
        # Only tail replies to clients
        if not is_tail:
            return
        # get account num from the uid
        acc = uid[2]
        send(('response', (uid, bank[acc])), to=client)

    def receive(msg=('withdrawl', (uid, amount)), from_=p):
        # If we are not the head server ignore client updates
        if not is_head and p not in servers:
            return
        # get account num from the update id
        acc = uid[2]
        # Deposit his $$$
        bank[acc] -= Decimal(amount)
        # forward the update
        fwd_update('withdrawl', uid, amount, bank[acc])

    def receive(msg=('deposit', (uid, amount)), from_=p):
        # If we are not the head server ignore client updates
        if not is_head and p not in servers:
            return
        # get account num from the update id
        acc = uid[2]
        # Deposit his $$$
        bank[acc] += Decimal(amount)
        # forward the update
        fwd_update('deposit', uid, amount, bank[acc])

    def fwd_update(update, uid, amount, new_balance):
        if is_tail:
            # Reply to the client
            output('Sending response to client')
            send(('response',(uid, new_balance)), to=uid[0])
        else:
            # Forward the update to successor
            output('Forwarding update to successor')
            send((update, (uid, amount)), to=sucessor)



def main():
    """Usage: client.da [num_clients]
    """
    nclients = int(sys.argv[1]) if len(sys.argv) > 1 else 1
    nservers = int(sys.argv[2]) if len(sys.argv) > 2 else 3
    config(clock='Lamport')
    clients = new(Client, num=nclients)
    servers = new(Server, num=nservers)
    slist = list(servers)

    setup(servers, [slist])

    head, tail = slist[0], slist[-1]
    print("head: %s, tail: %s" % (head, tail))
    for c in clients:
        setup(c, [servers, head, tail])

    start(servers)
    start(clients)
